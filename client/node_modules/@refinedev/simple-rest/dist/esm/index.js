import{stringify as L}from"query-string";import{stringify as p}from"query-string";var v=t=>{switch(t){case"ne":case"gte":case"lte":return`_${t}`;case"contains":return"_like";case"eq":default:return""}};var $=t=>{if(t&&t.length>0){let o=[],r=[];return t.map(e=>{o.push(e.field),r.push(e.order)}),{_sort:o,_order:r}}};var x=t=>{let o={};return t&&t.map(r=>{if(r.operator==="or"||r.operator==="and")throw new Error(`[@refinedev/simple-rest]: \`operator: ${r.operator}\` is not supported. You can create custom data provider. https://refine.dev/docs/api-reference/core/providers/data-provider/#creating-a-data-provider`);if("field"in r){let{field:e,operator:a,value:s}=r;if(e==="q"){o[e]=s;return}let n=v(a);o[`${e}${n}`]=s}}),o};import F from"axios";var _=F.create();_.interceptors.response.use(t=>t,t=>{var r,e,a;let o={...t,message:(e=(r=t.response)==null?void 0:r.data)==null?void 0:e.message,statusCode:(a=t.response)==null?void 0:a.status};return Promise.reject(o)});var w=(t,o=_)=>({getList:async({resource:r,pagination:e,filters:a,sorters:s})=>{let n=`${t}/${r}`,{current:m=1,pageSize:f=10,mode:c="server"}=e!=null?e:{},u=x(a),i={};c==="server"&&(i._start=(m-1)*f,i._end=m*f);let d=$(s);if(d){let{_sort:O,_order:S}=d;i._sort=O.join(","),i._order=S.join(",")}let{data:g,headers:y}=await o.get(`${n}?${p(i)}&${p(u)}`),l=+y["x-total-count"];return{data:g,total:l||g.length}},getMany:async({resource:r,ids:e})=>{let{data:a}=await o.get(`${t}/${r}?${p({id:e})}`);return{data:a}},create:async({resource:r,variables:e})=>{let a=`${t}/${r}`,{data:s}=await o.post(a,e);return{data:s}},update:async({resource:r,id:e,variables:a})=>{let s=`${t}/${r}/${e}`,{data:n}=await o.patch(s,a);return{data:n}},getOne:async({resource:r,id:e})=>{let a=`${t}/${r}/${e}`,{data:s}=await o.get(a);return{data:s}},deleteOne:async({resource:r,id:e,variables:a})=>{let s=`${t}/${r}/${e}`,{data:n}=await o.delete(s,{data:a});return{data:n}},getApiUrl:()=>t,custom:async({url:r,method:e,filters:a,sorters:s,payload:n,query:m,headers:f})=>{let c=`${r}?`;if(s){let d=$(s);if(d){let{_sort:g,_order:y}=d,l={_sort:g.join(","),_order:y.join(",")};c=`${c}&${p(l)}`}}if(a){let d=x(a);c=`${c}&${p(d)}`}m&&(c=`${c}&${p(m)}`),f&&(o.defaults.headers={...o.defaults.headers,...f});let u;switch(e){case"put":case"post":case"patch":u=await o[e](r,n);break;case"delete":u=await o.delete(r,{data:n});break;default:u=await o.get(c);break}let{data:i}=u;return Promise.resolve({data:i})}});var B=w;export{_ as axiosInstance,B as default,x as generateFilter,$ as generateSort,v as mapOperator,L as stringify};
//# sourceMappingURL=index.js.map