var k=Object.create;var l=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var E=Object.getOwnPropertyNames;var M=Object.getPrototypeOf,A=Object.prototype.hasOwnProperty;var D=(r,t)=>{for(var e in t)l(r,e,{get:t[e],enumerable:!0})},S=(r,t,e,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of E(t))!A.call(r,a)&&a!==e&&l(r,a,{get:()=>t[a],enumerable:!(o=I(t,a))||o.enumerable});return r};var H=(r,t,e)=>(e=r!=null?k(M(r)):{},S(t||!r||!r.__esModule?l(e,"default",{value:r,enumerable:!0}):e,r)),Q=r=>S(l({},"__esModule",{value:!0}),r);var h={};D(h,{axiosInstance:()=>_,default:()=>R,generateFilter:()=>x,generateSort:()=>$,mapOperator:()=>v,stringify:()=>P.stringify});module.exports=Q(h);var P=require("query-string");var u=require("query-string");var v=r=>{switch(r){case"ne":case"gte":case"lte":return`_${r}`;case"contains":return"_like";case"eq":default:return""}};var $=r=>{if(r&&r.length>0){let t=[],e=[];return r.map(o=>{t.push(o.field),e.push(o.order)}),{_sort:t,_order:e}}};var x=r=>{let t={};return r&&r.map(e=>{if(e.operator==="or"||e.operator==="and")throw new Error(`[@refinedev/simple-rest]: \`operator: ${e.operator}\` is not supported. You can create custom data provider. https://refine.dev/docs/api-reference/core/providers/data-provider/#creating-a-data-provider`);if("field"in e){let{field:o,operator:a,value:s}=e;if(o==="q"){t[o]=s;return}let n=v(a);t[`${o}${n}`]=s}}),t};var F=H(require("axios")),_=F.default.create();_.interceptors.response.use(r=>r,r=>{var e,o,a;let t={...r,message:(o=(e=r.response)==null?void 0:e.data)==null?void 0:o.message,statusCode:(a=r.response)==null?void 0:a.status};return Promise.reject(t)});var q=(r,t=_)=>({getList:async({resource:e,pagination:o,filters:a,sorters:s})=>{let n=`${r}/${e}`,{current:f=1,pageSize:g=10,mode:c="server"}=o!=null?o:{},p=x(a),i={};c==="server"&&(i._start=(f-1)*g,i._end=f*g);let d=$(s);if(d){let{_sort:b,_order:j}=d;i._sort=b.join(","),i._order=j.join(",")}let{data:y,headers:w}=await t.get(`${n}?${(0,u.stringify)(i)}&${(0,u.stringify)(p)}`),O=+w["x-total-count"];return{data:y,total:O||y.length}},getMany:async({resource:e,ids:o})=>{let{data:a}=await t.get(`${r}/${e}?${(0,u.stringify)({id:o})}`);return{data:a}},create:async({resource:e,variables:o})=>{let a=`${r}/${e}`,{data:s}=await t.post(a,o);return{data:s}},update:async({resource:e,id:o,variables:a})=>{let s=`${r}/${e}/${o}`,{data:n}=await t.patch(s,a);return{data:n}},getOne:async({resource:e,id:o})=>{let a=`${r}/${e}/${o}`,{data:s}=await t.get(a);return{data:s}},deleteOne:async({resource:e,id:o,variables:a})=>{let s=`${r}/${e}/${o}`,{data:n}=await t.delete(s,{data:a});return{data:n}},getApiUrl:()=>r,custom:async({url:e,method:o,filters:a,sorters:s,payload:n,query:f,headers:g})=>{let c=`${e}?`;if(s){let d=$(s);if(d){let{_sort:y,_order:w}=d,O={_sort:y.join(","),_order:w.join(",")};c=`${c}&${(0,u.stringify)(O)}`}}if(a){let d=x(a);c=`${c}&${(0,u.stringify)(d)}`}f&&(c=`${c}&${(0,u.stringify)(f)}`),g&&(t.defaults.headers={...t.defaults.headers,...g});let p;switch(o){case"put":case"post":case"patch":p=await t[o](e,n);break;case"delete":p=await t.delete(e,{data:n});break;default:p=await t.get(c);break}let{data:i}=p;return Promise.resolve({data:i})}});var R=q;
//# sourceMappingURL=index.js.map